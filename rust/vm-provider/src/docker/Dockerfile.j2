# VM Tool Self-Contained Development Container
ARG base_image=ubuntu:24.04
FROM ${base_image}

# Build arguments for users, and package versions
ARG PROJECT_USER=developer
ARG PROJECT_UID=1000
ARG PROJECT_GID=1000
ARG NODE_VERSION=22
ARG NVM_VERSION=v0.40.3
ARG PNPM_VERSION=10.12.3
ARG RUST_VERSION=stable

# Build arguments for package lists
ARG APT_PACKAGES
ARG NPM_PACKAGES
ARG PIP_PACKAGES
ARG PIPX_PACKAGES
ARG CARGO_PACKAGES

# Build arguments for git config
ARG GIT_USER_NAME
ARG GIT_USER_EMAIL
ARG GIT_PULL_REBASE
ARG GIT_INIT_DEFAULT_BRANCH
ARG GIT_CORE_EDITOR
ARG GIT_CORE_EXCLUDESFILE_CONTENT

# Snapshot detection - set to "true" when base_image is a pre-provisioned snapshot
ARG BASE_PREPROVISIONED=false

ARG TZ=UTC
ENV DEBIAN_FRONTEND=noninteractive
ENV LANG=en_US.UTF-8
ENV LANGUAGE=en_US:en
ENV LC_ALL=en_US.UTF-8
ENV EDITOR=vim
ENV VISUAL=vim
ENV PAGER="less -R"
ENV TERM=xterm-256color

# --- Base System Setup ---
# Skip for pre-provisioned snapshots to avoid permission conflicts
RUN if [ "$BASE_PREPROVISIONED" != "true" ]; then \
        # Set timezone (|| true: file may be on read-only layer in some base images)
        (echo "${TZ}" > /etc/timezone || true) && \
        apt-get update && apt-get install -y \
        locales \
        curl wget git git-lfs build-essential \
        python3 python3-dev python3-pip python3-venv \
        ansible \
        supervisor \
        sudo \
        nano vim \
        unzip zip tree jq \
        htop lsof \
        netcat-openbsd telnet dnsutils iputils-ping \
        zsh zsh-syntax-highlighting \
        tzdata \
        && locale-gen en_US.UTF-8 && update-locale LANG=en_US.UTF-8; \
    else \
        echo "Skipping base system setup (using pre-provisioned snapshot)"; \
    fi

# --- User Setup ---
# Force root user to avoid "user currently used by process 1" errors
USER root

# Ensure sudo is available (snapshots may not have it, needed for usermod and visudo)
RUN if ! command -v sudo >/dev/null 2>&1; then \
        echo "Installing sudo package..." && \
        apt-get update && apt-get install -y sudo && \
        rm -rf /var/lib/apt/lists/*; \
    fi

# Create/update user and group, handling both fresh images and snapshots
# For pre-provisioned snapshots: skip expensive UID/GID changes (use snapshot as-is)
# For fresh images: set up user with host UID/GID for proper file permissions
RUN if id -u ${PROJECT_USER} >/dev/null 2>&1; then \
        # User exists (likely from snapshot)
        OLD_UID=$(id -u ${PROJECT_USER}) && \
        OLD_GID=$(id -g ${PROJECT_USER}) && \
        OLD_GROUP=$(id -gn ${PROJECT_USER}) && \
        # Skip UID/GID adjustment for pre-provisioned snapshots (expensive: 2-3 min)
        # usermod/groupmod internally update ALL file ownerships, defeating snapshot optimization
        if [ "$BASE_PREPROVISIONED" = "true" ]; then \
            echo "Using snapshot user as-is: ${PROJECT_USER} ($OLD_UID:$OLD_GID)" && \
            echo "âš ï¸  Note: File permissions use snapshot UID/GID, not host UID/GID"; \
        elif [ "$OLD_UID" != "${PROJECT_UID}" ] || [ "$OLD_GID" != "${PROJECT_GID}" ]; then \
            echo "Adjusting UID/GID: $OLD_UID:$OLD_GID -> ${PROJECT_UID}:${PROJECT_GID}" && \
            # Change user UID first
            usermod -u ${PROJECT_UID} ${PROJECT_USER} && \
            # Handle GID: create new group if target GID conflicts
            if getent group ${PROJECT_GID} >/dev/null 2>&1; then \
                EXISTING_GROUP=$(getent group ${PROJECT_GID} | cut -d: -f1) && \
                if [ "$EXISTING_GROUP" != "$OLD_GROUP" ]; then \
                    echo "âš ï¸  GID ${PROJECT_GID} conflicts with $EXISTING_GROUP, adding user to existing group" && \
                    TARGET_GROUP="$EXISTING_GROUP"; \
                else \
                    TARGET_GROUP="$OLD_GROUP" && \
                    groupmod -g ${PROJECT_GID} "$TARGET_GROUP"; \
                fi; \
            else \
                TARGET_GROUP="$OLD_GROUP" && \
                groupmod -g ${PROJECT_GID} "$TARGET_GROUP"; \
            fi && \
            usermod -g "$TARGET_GROUP" ${PROJECT_USER} && \
            # Fix ownership of home directory files
            find /home/${PROJECT_USER} -user $OLD_UID -exec chown ${PROJECT_UID} {} + 2>/dev/null || true && \
            find /home/${PROJECT_USER} -group $OLD_GID -exec chgrp ${PROJECT_GID} {} + 2>/dev/null || true; \
        else \
            echo "UID/GID already matches (${PROJECT_UID}:${PROJECT_GID}), skipping adjustment"; \
        fi; \
    else \
        # User doesn't exist, create them
        echo "Creating user ${PROJECT_USER} (${PROJECT_UID}:${PROJECT_GID})" && \
        # Handle group creation with conflict detection
        if getent group ${PROJECT_GID} >/dev/null 2>&1; then \
            EXISTING_GROUP=$(getent group ${PROJECT_GID} | cut -d: -f1) && \
            echo "âš ï¸  GID ${PROJECT_GID} belongs to $EXISTING_GROUP, using existing group" && \
            TARGET_GROUP="$EXISTING_GROUP"; \
        else \
            TARGET_GROUP="${PROJECT_USER}" && \
            groupadd -g ${PROJECT_GID} "$TARGET_GROUP"; \
        fi && \
        useradd -m -u ${PROJECT_UID} -g "$TARGET_GROUP" -s /bin/zsh ${PROJECT_USER}; \
    fi && \
    usermod -aG sudo ${PROJECT_USER} && \
    mkdir -p /etc/sudoers.d && \
    echo "${PROJECT_USER} ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/90-nopasswd-user && \
    chmod 0440 /etc/sudoers.d/90-nopasswd-user && \
    if command -v visudo >/dev/null 2>&1; then \
        visudo -c -f /etc/sudoers.d/90-nopasswd-user; \
    fi

# --- Language Runtimes & Package Managers ---
# Install NVM with proper permissions
# Note: install -d runs as root and creates directory with specified ownership
# This handles snapshots where /home/developer may have different UID/GID
RUN --mount=type=cache,target=/home/${PROJECT_USER}/.nvm/.cache,uid=${PROJECT_UID},gid=${PROJECT_GID} \
    mkdir -p /home/${PROJECT_USER}/.nvm && \
    chown ${PROJECT_UID}:${PROJECT_GID} /home/${PROJECT_USER}/.nvm && \
    su - ${PROJECT_USER} -c 'if [ ! -s "$HOME/.nvm/nvm.sh" ]; then curl -o- "https://raw.githubusercontent.com/nvm-sh/nvm/'${NVM_VERSION}'/install.sh" | bash; fi && export NVM_DIR="$HOME/.nvm" && [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh" && (nvm list | grep -q "v'${NODE_VERSION}'" || nvm install '${NODE_VERSION}') && nvm use '${NODE_VERSION}' && nvm alias default '${NODE_VERSION}' && corepack enable && corepack prepare pnpm@'${PNPM_VERSION}' --activate'

# --- Git Configuration ---
USER ${PROJECT_USER}
WORKDIR /home/${PROJECT_USER}
SHELL ["/bin/bash", "-c"]
RUN if [ -n "${GIT_USER_NAME}" ]; then git config --global user.name "${GIT_USER_NAME}"; fi && \
    if [ -n "${GIT_USER_EMAIL}" ]; then git config --global user.email "${GIT_USER_EMAIL}"; fi && \
    if [ -n "${GIT_PULL_REBASE}" ]; then git config --global pull.rebase "${GIT_PULL_REBASE}"; fi && \
    if [ -n "${GIT_INIT_DEFAULT_BRANCH}" ]; then git config --global init.defaultBranch "${GIT_INIT_DEFAULT_BRANCH}"; fi && \
    if [ -n "${GIT_CORE_EDITOR}" ]; then git config --global core.editor "${GIT_CORE_EDITOR}"; fi && \
    if [ -n "${GIT_CORE_EXCLUDESFILE_CONTENT}" ]; then echo "${GIT_CORE_EXCLUDESFILE_CONTENT}" > /home/${PROJECT_USER}/.gitignore_global && git config --global core.excludesfile /home/${PROJECT_USER}/.gitignore_global; fi

RUN --mount=type=cache,target=/home/${PROJECT_USER}/.rustup \
    if [ -n "${CARGO_PACKAGES}" ]; then \
        # Fix cache permissions if they exist from a different UID \
        if [ -d "/home/${PROJECT_USER}/.rustup" ]; then \
            find "/home/${PROJECT_USER}/.rustup" ! -user ${PROJECT_UID} -exec chown ${PROJECT_UID}:${PROJECT_GID} {} + 2>/dev/null || true; \
        fi && \
        su - ${PROJECT_USER} -c 'curl --proto "=https" --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain ${RUST_VERSION} --no-modify-path'; \
    fi

RUN if [ -n "${PIPX_PACKAGES}" ]; then \
    python3 -m pip install --user --break-system-packages pipx; \
    python3 -m pipx ensurepath; \
fi

# --- PATH Configuration ---
# Set up environment for package managers (must come before config/shell setup)
ENV NVM_DIR=/home/${PROJECT_USER}/.nvm
ENV PATH="/home/${PROJECT_USER}/.cargo/bin:/home/${PROJECT_USER}/.local/bin:${NVM_DIR}/versions/node/v${NODE_VERSION}/bin:${PATH}"


# --- Resource & Configuration Embedding ---
USER root
RUN mkdir -p /app/shared/ansible /app/shared/services /app/shared/templates /app/shared/settings
COPY --chown=${PROJECT_UID}:${PROJECT_GID} shared /app/shared

# --- Cargo Registry Configuration ---
USER ${PROJECT_USER}
RUN echo '' >> /home/${PROJECT_USER}/.zshrc && \
    echo '# --- VM CARGO REGISTRY CONFIGURATION ---' >> /home/${PROJECT_USER}/.zshrc && \
    echo 'if [ -n "$VM_CARGO_REGISTRY_HOST" ] && [ -n "$VM_CARGO_REGISTRY_PORT" ]; then' >> /home/${PROJECT_USER}/.zshrc && \
    echo '    mkdir -p ~/.cargo' >> /home/${PROJECT_USER}/.zshrc && \
    echo '    cat > ~/.cargo/config.toml << EOF' >> /home/${PROJECT_USER}/.zshrc && \
    echo '[source.crates-io]' >> /home/${PROJECT_USER}/.zshrc && \
    echo 'replace-with = "vm-registry"' >> /home/${PROJECT_USER}/.zshrc && \
    echo '' >> /home/${PROJECT_USER}/.zshrc && \
    echo '[source.vm-registry]' >> /home/${PROJECT_USER}/.zshrc && \
    echo "registry = \"sparse+http://\${VM_CARGO_REGISTRY_HOST}:\${VM_CARGO_REGISTRY_PORT}/cargo/\"" >> /home/${PROJECT_USER}/.zshrc && \
    echo '' >> /home/${PROJECT_USER}/.zshrc && \
    echo '[net]' >> /home/${PROJECT_USER}/.zshrc && \
    echo 'retry = 2' >> /home/${PROJECT_USER}/.zshrc && \
    echo 'EOF' >> /home/${PROJECT_USER}/.zshrc && \
    echo 'fi' >> /home/${PROJECT_USER}/.zshrc

# --- Git Worktree Auto-Repair Configuration ---
# Create shared initialization script that runs for ALL shells (interactive, non-interactive, bash, zsh, sh)
USER root
RUN mkdir -p /etc/profile.d && \
    cat > /etc/profile.d/vm-worktree-repair.sh << 'EOF'
#!/bin/sh
# VM Git Worktree Auto-Repair
# Automatically repairs worktree paths when switching between host and container
if [ -d "/workspace/.git" ] || [ -f "/workspace/.git" ]; then
    # Run in background, suppress all output, ignore errors
    (cd /workspace 2>/dev/null && git worktree repair 2>/dev/null || true) &
fi
EOF

# Make executable and source from all shell configs
RUN chmod +x /etc/profile.d/vm-worktree-repair.sh && \
    echo '. /etc/profile.d/vm-worktree-repair.sh' >> /etc/bash.bashrc && \
    echo '. /etc/profile.d/vm-worktree-repair.sh' >> /home/${PROJECT_USER}/.bashrc && \
    echo '. /etc/profile.d/vm-worktree-repair.sh' >> /home/${PROJECT_USER}/.zshrc

# --- Bash-only Guard for .bashrc ---
# Add early return at the TOP of .bashrc if not running in bash
# This prevents zsh from executing bash-specific commands in the stock .bashrc
RUN sed -i '1i# Early return if not running in bash (prevents zsh errors)\n[ -z "$BASH_VERSION" ] && return\n' /home/${PROJECT_USER}/.bashrc

# --- Git Worktree Helper Configuration ---
# Set VM_WORKTREES environment variable and create vm-worktree command
RUN echo 'export VM_WORKTREES={{ worktrees_base_dir }}' >> /etc/bash.bashrc && \
    echo 'export VM_WORKTREES={{ worktrees_base_dir }}' >> /home/${PROJECT_USER}/.bashrc && \
    echo 'export VM_WORKTREES={{ worktrees_base_dir }}' >> /home/${PROJECT_USER}/.zshrc

# Install vm-worktree helper command
COPY vm-worktree.sh /usr/local/bin/vm-worktree
RUN chmod +x /usr/local/bin/vm-worktree

# --- Shell History Configuration ---
# Create persistent history directory as root to handle snapshots with different UID/GID
USER root
RUN mkdir -p /home/${PROJECT_USER}/.shell_history && \
    chown ${PROJECT_UID}:${PROJECT_GID} /home/${PROJECT_USER}/.shell_history && \
    chmod 700 /home/${PROJECT_USER}/.shell_history

# Switch back to project user for configuration
USER ${PROJECT_USER}

# Note: Zsh history is now configured in zshrc.j2 template

# Configure Bash history (guard bash-specific commands for zsh compatibility)
RUN echo '' >> /home/${PROJECT_USER}/.bashrc && \
    echo '# --- Shell History Settings ---' >> /home/${PROJECT_USER}/.bashrc && \
    echo 'export HISTSIZE=50000' >> /home/${PROJECT_USER}/.bashrc && \
    echo 'export HISTFILESIZE=50000' >> /home/${PROJECT_USER}/.bashrc && \
    echo 'export HISTFILE=~/.shell_history/bash_history' >> /home/${PROJECT_USER}/.bashrc && \
    echo 'export HISTCONTROL=ignoredups:erasedups' >> /home/${PROJECT_USER}/.bashrc && \
    echo '# Bash-specific commands (skip if sourced by zsh)' >> /home/${PROJECT_USER}/.bashrc && \
    echo 'if [ -n "$BASH_VERSION" ]; then' >> /home/${PROJECT_USER}/.bashrc && \
    echo '    shopt -s histappend' >> /home/${PROJECT_USER}/.bashrc && \
    echo '    PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"' >> /home/${PROJECT_USER}/.bashrc && \
    echo 'fi' >> /home/${PROJECT_USER}/.bashrc

# --- Git Worktree Discovery Message ---
RUN echo '' >> /home/${PROJECT_USER}/.zshrc && \
    echo '# Show vm-worktree hint on first login' >> /home/${PROJECT_USER}/.zshrc && \
    echo 'if [[ ! -f ~/.vm_worktree_tip_shown ]] && [[ -n "${VM_WORKTREES:-}" ]]; then' >> /home/${PROJECT_USER}/.zshrc && \
    echo '    echo ""' >> /home/${PROJECT_USER}/.zshrc && \
    echo '    echo "ðŸ’¡ Tip: Use \\033[1;36mvm-worktree\\033[0m to create git worktrees that work on both host and container:"' >> /home/${PROJECT_USER}/.zshrc && \
    echo '    echo "  \\033[0;32mvm-worktree add feature-x\\033[0m   # Create new worktree"' >> /home/${PROJECT_USER}/.zshrc && \
    echo '    echo "  \\033[0;32mvm-worktree list\\033[0m            # List all worktrees"' >> /home/${PROJECT_USER}/.zshrc && \
    echo '    echo ""' >> /home/${PROJECT_USER}/.zshrc && \
    echo '    touch ~/.vm_worktree_tip_shown' >> /home/${PROJECT_USER}/.zshrc && \
    echo 'fi' >> /home/${PROJECT_USER}/.zshrc

RUN echo '' >> /home/${PROJECT_USER}/.bashrc && \
    echo '# Show vm-worktree hint on first login (bash only)' >> /home/${PROJECT_USER}/.bashrc && \
    echo 'if [ -n "$BASH_VERSION" ]; then' >> /home/${PROJECT_USER}/.bashrc && \
    echo '  if [[ ! -f ~/.vm_worktree_tip_shown ]] && [[ -n "${VM_WORKTREES:-}" ]]; then' >> /home/${PROJECT_USER}/.bashrc && \
    echo '    echo ""' >> /home/${PROJECT_USER}/.bashrc && \
    echo '    echo -e "ðŸ’¡ Tip: Use \\033[1;36mvm-worktree\\033[0m to create git worktrees that work on both host and container:"' >> /home/${PROJECT_USER}/.bashrc && \
    echo '    echo -e "  \\033[0;32mvm-worktree add feature-x\\033[0m   # Create new worktree"' >> /home/${PROJECT_USER}/.bashrc && \
    echo '    echo -e "  \\033[0;32mvm-worktree list\\033[0m            # List all worktrees"' >> /home/${PROJECT_USER}/.bashrc && \
    echo '    echo ""' >> /home/${PROJECT_USER}/.bashrc && \
    echo '    touch ~/.vm_worktree_tip_shown' >> /home/${PROJECT_USER}/.bashrc && \
    echo '  fi' >> /home/${PROJECT_USER}/.bashrc && \
    echo 'fi' >> /home/${PROJECT_USER}/.bashrc

# --- Worktree Prompt Indicator ---
# Add prompt indicator for bash
RUN echo '' >> /home/${PROJECT_USER}/.bashrc && \
    echo '# Show worktree in prompt if inside one (bash only)' >> /home/${PROJECT_USER}/.bashrc && \
    echo 'if [ -n "$BASH_VERSION" ]; then' >> /home/${PROJECT_USER}/.bashrc && \
    echo '  if [[ -n "${VM_WORKTREES:-}" ]] && [[ "$PWD" == "$VM_WORKTREES"/* ]]; then' >> /home/${PROJECT_USER}/.bashrc && \
    echo '    WT_NAME=$(basename "$PWD")' >> /home/${PROJECT_USER}/.bashrc && \
    echo '    PS1="(worktree:$WT_NAME) $PS1"' >> /home/${PROJECT_USER}/.bashrc && \
    echo '  fi' >> /home/${PROJECT_USER}/.bashrc && \
    echo 'fi' >> /home/${PROJECT_USER}/.bashrc

# Add prompt indicator for zsh
RUN echo '' >> /home/${PROJECT_USER}/.zshrc && \
    echo '# Show worktree in prompt if inside one' >> /home/${PROJECT_USER}/.zshrc && \
    echo 'precmd() {' >> /home/${PROJECT_USER}/.zshrc && \
    echo '    if [[ -n "${VM_WORKTREES:-}" ]] && [[ "$PWD" == "$VM_WORKTREES"/* ]]; then' >> /home/${PROJECT_USER}/.zshrc && \
    echo '        WT_NAME=$(basename "$PWD")' >> /home/${PROJECT_USER}/.zshrc && \
    echo '        PROMPT="(worktree:$WT_NAME) %~ %# "' >> /home/${PROJECT_USER}/.zshrc && \
    echo '    else' >> /home/${PROJECT_USER}/.zshrc && \
    echo '        PROMPT="%~ %# "' >> /home/${PROJECT_USER}/.zshrc && \
    echo '    fi' >> /home/${PROJECT_USER}/.zshrc && \
    echo '}' >> /home/${PROJECT_USER}/.zshrc

# --- Package Installation ---
# Moved to end for optimal layer caching (60% faster when only packages change)
# When package lists change, only these final layers need to rebuild

USER root
RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
    --mount=type=cache,target=/var/lib/apt/lists,sharing=locked \
    if [ -n "${APT_PACKAGES}" ]; then \
        echo "Checking APT packages: ${APT_PACKAGES}"; \
        PACKAGES_TO_INSTALL=""; \
        for pkg in ${APT_PACKAGES}; do \
            if ! dpkg -l | grep -q "^ii  $pkg "; then \
                PACKAGES_TO_INSTALL="$PACKAGES_TO_INSTALL $pkg"; \
            else \
                echo "Skipping $pkg (already installed)"; \
            fi; \
        done; \
        if [ -n "$PACKAGES_TO_INSTALL" ]; then \
            # Skip apt-get update if cache is recent (< 24h) - saves 30-60s
            if [ ! -f /var/lib/apt/lists/*Packages ] || \
               [ $(find /var/lib/apt/lists -name '*Packages' -mtime -1 2>/dev/null | wc -l) -eq 0 ]; then \
                echo "Updating APT cache..."; \
                apt-get update; \
            else \
                echo "APT cache is recent, skipping update"; \
            fi && \
            apt-get install -y $PACKAGES_TO_INSTALL; \
        else \
            echo "All APT packages already installed"; \
        fi; \
    fi

# NPM Package Installation
# Note: Run as root first to fix cache permissions, then switch to user for npm install
RUN --mount=type=cache,target=/home/${PROJECT_USER}/.npm \
    if [ -n "${NPM_PACKAGES}" ]; then \
        echo "Checking NPM packages: ${NPM_PACKAGES}"; \
        # Fix cache permissions if they exist from a different UID \
        if [ -d "/home/${PROJECT_USER}/.npm" ]; then \
            find "/home/${PROJECT_USER}/.npm" ! -user ${PROJECT_UID} -exec chown ${PROJECT_UID}:${PROJECT_GID} {} + 2>/dev/null || true; \
        fi && \
        su - ${PROJECT_USER} -c '. "$NVM_DIR/nvm.sh" && \
        for pkg in ${NPM_PACKAGES}; do \
            if ! npm list -g --depth=0 "$pkg" >/dev/null 2>&1; then \
                echo "Installing $pkg..."; \
                npm install -g "$pkg"; \
            else \
                echo "Skipping $pkg (already installed)"; \
            fi; \
        done'; \
    fi
USER ${PROJECT_USER}

# Python Package Installation
# Note: Run as root first to fix cache permissions, then switch to user for pip install
RUN --mount=type=cache,target=/home/${PROJECT_USER}/.cache/pip \
    if [ -n "${PIP_PACKAGES}" ]; then \
        echo "Checking Python packages: ${PIP_PACKAGES}"; \
        # Fix cache permissions if they exist from a different UID \
        if [ -d "/home/${PROJECT_USER}/.cache/pip" ]; then \
            find "/home/${PROJECT_USER}/.cache/pip" ! -user ${PROJECT_UID} -exec chown ${PROJECT_UID}:${PROJECT_GID} {} + 2>/dev/null || true; \
        fi && \
        su - ${PROJECT_USER} -c 'for pkg in ${PIP_PACKAGES}; do \
            if ! pip3 show "$pkg" >/dev/null 2>&1; then \
                echo "Installing $pkg..."; \
                pip3 install --user --break-system-packages "$pkg"; \
            else \
                echo "Skipping $pkg (already installed)"; \
            fi; \
        done'; \
    fi

# Cargo Package Installation
# Note: Run as root first to fix cache permissions, then switch to user for cargo install
RUN --mount=type=cache,target=/home/${PROJECT_USER}/.cargo/registry \
    --mount=type=cache,target=/home/${PROJECT_USER}/.cargo/git \
    if [ -n "${CARGO_PACKAGES}" ]; then \
        echo "Installing Cargo packages: ${CARGO_PACKAGES}"; \
        # Fix cache permissions if they exist from a different UID \
        if [ -d "/home/${PROJECT_USER}/.cargo/registry" ]; then \
            find "/home/${PROJECT_USER}/.cargo/registry" ! -user ${PROJECT_UID} -exec chown ${PROJECT_UID}:${PROJECT_GID} {} + 2>/dev/null || true; \
        fi && \
        if [ -d "/home/${PROJECT_USER}/.cargo/git" ]; then \
            find "/home/${PROJECT_USER}/.cargo/git" ! -user ${PROJECT_UID} -exec chown ${PROJECT_UID}:${PROJECT_GID} {} + 2>/dev/null || true; \
        fi && \
        su - ${PROJECT_USER} -c '. "$HOME/.cargo/env" && \
        for pkg in ${CARGO_PACKAGES}; do \
            if ! cargo install --list | grep -q "^${pkg} "; then \
                echo "Installing ${pkg}..."; \
                cargo install "${pkg}"; \
            else \
                echo "Skipping ${pkg} (already installed)"; \
            fi; \
        done; \
    fi

# --- Finalization ---
USER ${PROJECT_USER}
WORKDIR /workspace
CMD ["tail", "-f", "/dev/null"]
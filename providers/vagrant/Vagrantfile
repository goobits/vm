# -*- mode: ruby -*-
# vi: set ft=ruby :

require 'json'
require 'set'

Vagrant.configure("2") do |config|
  # Use the shared config processor for unified configuration loading
  # This replaces the Ruby deep_merge logic with the unified bash processor
  config_processor = File.expand_path("../../shared/config-processor.sh", File.dirname(__FILE__))
  config_file = ENV['VM_CONFIG'] || "__SCAN__"
  
  # Load and validate configuration using shared config processor
  config_json = `"#{config_processor}" load-config "#{config_file}" 2>&1`
  config_exit_code = $?.exitstatus
  
  if config_exit_code != 0
    puts config_json
    abort "VM configuration loading failed"
  end
  
  # Parse the JSON configuration
  begin
    project_config = JSON.parse(config_json)
  rescue JSON::ParserError => e
    puts "‚ùå Failed to parse configuration JSON: #{e.message}"
    abort "VM configuration parsing failed"
  end
  
  # Extract configuration values after validation
  project_name = project_config['project']['name']
  
  # Define a named machine instead of using default
  config.vm.define project_name do |machine|
    machine.vm.hostname = project_config['project']['hostname']
    machine.vm.box = project_config['vm']['box']
    vm_memory = project_config['vm']['memory']
    vm_cpus = project_config['vm']['cpus']
    vm_user = project_config['vm']['user']
    workspace_path = project_config['project']['workspace_path']
  
    # Forward ports from config
    # Default to localhost-only for security (override with vm.port_binding)
    port_binding = project_config.dig('vm', 'port_binding') || "127.0.0.1"
    
    # Collect explicit ports to avoid conflicts with port range
    explicit_ports = Set.new
    (project_config['ports'] || {}).each do |service, port|
      explicit_ports.add(port)
      if port_binding == "0.0.0.0"
        # Explicitly bind to all interfaces if requested
        machine.vm.network "forwarded_port", guest: port, host: port, auto_correct: true
      else
        # Default: bind to specified IP (localhost by default)
        machine.vm.network "forwarded_port", guest: port, host: port, host_ip: port_binding, auto_correct: true
      end
    end
    
    # Forward port range if specified (skip explicit ports to avoid conflicts)
    port_range = project_config['port_range']
    if port_range && port_range.match?(/^\d+-\d+$/)
      range_parts = port_range.split('-')
      range_start = range_parts[0].to_i  
      range_end = range_parts[1].to_i
      
      if range_start < range_end && range_start >= 1 && range_end <= 65535
        (range_start..range_end).each do |port|
          # Skip if port already explicitly mapped in ports: section
          next if explicit_ports.include?(port)
          
          if port_binding == "0.0.0.0"
            machine.vm.network "forwarded_port", guest: port, host: port, auto_correct: true
          else
            machine.vm.network "forwarded_port", guest: port, host: port, host_ip: port_binding, auto_correct: true  
          end
        end
      end
    end
  
    # VirtualBox provider (default)
    machine.vm.provider "virtualbox" do |vb|
      # Set a clean VM name based on project
      vb.name = "#{project_name}-dev"
      
      vb.memory = vm_memory
      vb.cpus = vm_cpus
      vb.gui = false
      
      # Audio support configuration
      if project_config.dig('services', 'audio', 'enabled') != false
        vb.customize ["modifyvm", :id, "--audio", "default"]
        vb.customize ["modifyvm", :id, "--audiocontroller", "hda"]
        vb.customize ["modifyvm", :id, "--audioout", "on"]
        if project_config.dig('services', 'audio', 'share_microphone')
          vb.customize ["modifyvm", :id, "--audioin", "on"]
        end
      end
      
      # GPU acceleration configuration
      if project_config.dig('services', 'gpu', 'enabled')
        vb.customize ["modifyvm", :id, "--accelerate3d", "on"]
        gpu_memory = project_config.dig('services', 'gpu', 'memory_mb') || 256
        vb.customize ["modifyvm", :id, "--vram", gpu_memory]
      end
    end
    
    # Parallels provider (alternative)
    machine.vm.provider "parallels" do |prl|
      # Set a clean VM name based on project
      prl.name = "#{project_name}-dev"
      
      prl.memory = vm_memory
      prl.cpus = vm_cpus
      
      # Ensure time synchronization
      prl.customize ["set", :id, "--time-sync", "on"]
      
      # Audio support configuration
      if project_config.dig('services', 'audio', 'enabled') != false
        prl.customize ["set", :id, "--sound-output", "on"]
        if project_config.dig('services', 'audio', 'share_microphone')
          prl.customize ["set", :id, "--sound-input", "on"]
        end
      end
      
      # GPU acceleration configuration
      if project_config.dig('services', 'gpu', 'enabled')
        prl.customize ["set", :id, "--3d-accelerate", "highest"]
        gpu_memory = project_config.dig('services', 'gpu', 'memory_mb') || 256
        prl.customize ["set", :id, "--video-memory", gpu_memory]
      end
    end
  
    # SSH configuration
    machine.ssh.forward_agent = true
    machine.ssh.forward_x11 = true
    machine.ssh.connect_timeout = 120
    machine.ssh.insert_key = true
  
    # Mount project root as workspace
    source_path = ENV['VM_PROJECT_DIR'] || "../.."
    machine.vm.synced_folder source_path, workspace_path
    
    # Mount vm tool directory for access to ansible files
    machine.vm.synced_folder File.expand_path("../..", File.dirname(__FILE__)), "/vm-tool"
    
    machine.vm.synced_folder ".", "/vagrant", disabled: true
    
    # Handle Claude sync if enabled
    if project_config['claude_sync'] == true
      claude_host_path = File.expand_path("~/.claude/vms/#{project_name}")
      claude_guest_path = "/home/#{vm_user}/.claude"
      machine.vm.synced_folder claude_host_path, claude_guest_path, create: true
    end
    
    # Handle database persistence if enabled
    if project_config['persist_databases'] == true
      vm_data_path = File.join(File.dirname(config_file), '.vm', 'data')
      
      # PostgreSQL
      if project_config.dig('services', 'postgresql', 'enabled')
        machine.vm.synced_folder "#{vm_data_path}/postgres", "/var/lib/postgresql", 
          create: true, owner: "postgres", group: "postgres"
      end
      
      # Redis
      if project_config.dig('services', 'redis', 'enabled')
        machine.vm.synced_folder "#{vm_data_path}/redis", "/var/lib/redis", 
          create: true, owner: "redis", group: "redis"
      end
      
      # MongoDB
      if project_config.dig('services', 'mongodb', 'enabled')
        machine.vm.synced_folder "#{vm_data_path}/mongodb", "/var/lib/mongodb", 
          create: true, owner: "mongodb", group: "mongodb"
      end
      
      # MySQL
      if project_config.dig('services', 'mysql', 'enabled')
        machine.vm.synced_folder "#{vm_data_path}/mysql", "/var/lib/mysql", 
          create: true, owner: "mysql", group: "mysql"
      end
    end

    # Package linking support (npm, pip, cargo)
    if project_config['npm_packages'] && !project_config['npm_packages'].empty?
      puts "üîó Checking for linked npm packages..."
      
      # Load shared utilities
      link_detector_script = File.join(File.dirname(__FILE__), '..', '..', 'shared', 'link-detector.sh')
      security_utils_script = File.join(File.dirname(__FILE__), '..', '..', 'shared', 'security-utils.sh')
      mount_utils_script = File.join(File.dirname(__FILE__), '..', '..', 'shared', 'mount-utils.sh')
      
      if File.exist?(link_detector_script)
        # Convert npm_packages array to space-separated string for bash
        npm_packages_str = project_config['npm_packages'].map { |pkg| "'#{pkg}'" }.join(' ')
        
        # Use shared link-detector.sh to detect linked packages with error output for user feedback
        npm_detection_cmd = "bash -c \"source '#{link_detector_script}' && generate_package_mounts npm #{npm_packages_str}\""
        linked_volumes_output = `#{npm_detection_cmd} 2>&1`
        exit_status = $?.exitstatus
        
        # Extract volume mappings (stdout) and user messages (stderr)
        linked_volumes = linked_volumes_output.lines.select { |line| line.include?(':') && !line.include?('üì¶') }.join.strip
        user_messages = linked_volumes_output.lines.select { |line| line.include?('üì¶') }.join
        
        # Display user messages
        print user_messages unless user_messages.empty?
        
        if exit_status == 0 && !linked_volumes.empty?
          linked_volumes.split("\n").each do |volume_mapping|
            next if volume_mapping.empty?
            
            # Parse Docker volume format: source:target:permissions
            parts = volume_mapping.split(':')
            next unless parts.length >= 2
            
            source_path = parts[0]
            target_path = parts[1]
            permissions = parts[2] || 'delegated'
            
            # Convert target path to match Ansible expectations
            # Ansible expects /workspace/.npm_links/<safe_package_name>
            # Extract package name from target path and apply same sanitization as Ansible
            package_name = File.basename(target_path)
            safe_package_name = package_name.gsub(/[@\/]/, '-')
            sanitized_target_path = "/workspace/.npm_links/#{safe_package_name}"
            
            # Basic security validation for source path
            begin
              resolved_source = File.realpath(source_path)
              
              # Validate source path exists and is readable
              if File.directory?(resolved_source) && File.readable?(resolved_source)
                # Additional security check: ensure not mounting system paths
                if resolved_source.start_with?('/etc/') || resolved_source.start_with?('/usr/bin/') || 
                   resolved_source.start_with?('/bin/') || resolved_source.start_with?('/sbin/')
                  puts "‚ö†Ô∏è  Skipping system path: #{resolved_source}"
                  next
                end
                
                # Use appropriate sync type based on permissions
                sync_options = {
                  type: "virtualbox",
                  create: true,
                  owner: vm_user,
                  group: vm_user
                }
                
                # For read-only mounts, use rsync for better performance
                if permissions == 'ro'
                  sync_options[:type] = "rsync"
                  sync_options[:rsync__exclude] = [".git/", "node_modules/", ".DS_Store"]
                  sync_options[:rsync__args] = ["--verbose", "--archive", "--delete", "-z"]
                end
                
                machine.vm.synced_folder resolved_source, sanitized_target_path, sync_options
                puts "üì¶ Linked package: #{package_name} -> #{sanitized_target_path}"
              else
                puts "‚ö†Ô∏è  Warning: NPM linked package path not accessible: #{source_path}"
              end
            rescue => e
              puts "‚ö†Ô∏è  Error processing NPM linked package path #{source_path}: #{e.message}"
            end
          end
        elsif !project_config['npm_packages'].empty?
          puts "‚ÑπÔ∏è  No linked NPM packages found for: #{project_config['npm_packages'].join(', ')}"
        end
      else
        puts "‚ö†Ô∏è  Warning: NPM utilities not found at #{npm_utils_script}"
      end
    end

    # Package linking support for pip
    if project_config['pip_packages'] && !project_config['pip_packages'].empty?
      puts "üîó Checking for linked pip packages..."
      
      link_detector_script = File.join(File.dirname(__FILE__), '..', '..', 'shared', 'link-detector.sh')
      
      if File.exist?(link_detector_script)
        pip_packages_str = project_config['pip_packages'].map { |pkg| "'#{pkg}'" }.join(' ')
        
        pip_detection_cmd = "bash -c \"source '#{link_detector_script}' && generate_package_mounts pip #{pip_packages_str}\""
        linked_volumes_output = `#{pip_detection_cmd} 2>&1`
        exit_status = $?.exitstatus
        
        linked_volumes = linked_volumes_output.lines.select { |line| line.include?(':') && !line.include?('üì¶') }.join.strip
        user_messages = linked_volumes_output.lines.select { |line| line.include?('üì¶') }.join
        
        print user_messages unless user_messages.empty?
        
        if exit_status == 0 && !linked_volumes.empty?
          linked_volumes.split("\n").each do |volume_mapping|
            next if volume_mapping.empty?
            
            parts = volume_mapping.split(':')
            next unless parts.length >= 2
            
            source_path = parts[0]
            target_path = parts[1]
            permissions = parts[2] || 'delegated'
            
            begin
              resolved_source = File.realpath(source_path)
              
              if File.directory?(resolved_source) && File.readable?(resolved_source)
                if resolved_source.start_with?('/etc/') || resolved_source.start_with?('/usr/bin/') || 
                   resolved_source.start_with?('/bin/') || resolved_source.start_with?('/sbin/')
                  puts "‚ö†Ô∏è  Skipping system path: #{resolved_source}"
                  next
                end
                
                sync_options = {
                  type: "virtualbox",
                  create: true,
                  owner: vm_user,
                  group: vm_user
                }
                
                if permissions == 'ro'
                  sync_options[:type] = "rsync"
                  sync_options[:rsync__exclude] = [".git/", "dist/", "*.pyc", "__pycache__/"]
                  sync_options[:rsync__args] = ["--verbose", "--archive", "--delete", "-z"]
                end
                
                machine.vm.synced_folder resolved_source, target_path, sync_options
                puts "üì¶ Linked package: #{File.basename(target_path)} -> #{target_path}"
              else
                puts "‚ö†Ô∏è  Warning: Pip linked package path not accessible: #{source_path}"
              end
            rescue => e
              puts "‚ö†Ô∏è  Error processing Pip linked package path #{source_path}: #{e.message}"
            end
          end
        elsif !project_config['pip_packages'].empty?
          puts "‚ÑπÔ∏è  No linked Pip packages found for: #{project_config['pip_packages'].join(', ')}"
        end
      else
        puts "‚ö†Ô∏è  Warning: Link detector script not found at #{link_detector_script}"
      end
    end
  
    # Write merged configuration for Ansible to use
    machine.vm.provision "shell", inline: <<-SHELL
      echo "Ensuring SSH service is running..."
      sudo systemctl enable ssh
      sudo systemctl start ssh
      
      echo "Temporarily disabling UFW for provisioning..."
      sudo ufw disable || true
      sudo ufw allow ssh || true
      
      echo "Ansible playbook available at /vm-tool/shared/ansible/"
      
      # Write merged configuration for Ansible (separate from project vm.yaml)
      cat > /tmp/vm-config.json << 'EOF'
#{JSON.pretty_generate(project_config)}
EOF
    SHELL
    
    # Provision with Ansible
    machine.vm.provision "ansible_local" do |ansible|
      ansible.playbook = "playbook.yml"
      ansible.provisioning_path = "/vm-tool/shared/ansible"
      ansible.install_mode = "pip"
      ansible.version = "latest"
    end
  end
end